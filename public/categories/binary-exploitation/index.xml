<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Binary Exploitation on Dexter</title>
    <link>http://localhost:1313/blog/categories/binary-exploitation/</link>
    <description>Recent content in Binary Exploitation on Dexter</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 21 Jan 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/blog/categories/binary-exploitation/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>KnightCTF</title>
      <link>http://localhost:1313/blog/posts/ctfs/knightctf/</link>
      <pubDate>Sun, 21 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/posts/ctfs/knightctf/</guid>
      <description>&lt;h1 id=&#34;get-the-sword&#34;&gt;Get The Sword&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Can you get the sword ?&#xA;Author : froghunter&#xA;Download Link - 1 : https://drive.google.com/file/d/1HsQMxiZlP5978DzqnoZs6g6QOnCzVm_G/view&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Doing some basic file checks we see that the binary is a 32bit LSB executable which will really affect how we approach this challenge. The binary is also dynamically linked and not stripped.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;dexter@lab:~/the-lab/knights/rev$ file get_sword    &#xA;get_sword: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=4a9b260935bf815a04350e3bb9e0e4422f504b2a, for GNU/Linux 4.4.0, not stripped&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now looking at the securities set with the binary, we see that it really is not protected. We have no canary, meaning we can perform a buffer overflow with ease. NX is also unkown which would make executing shellcode on the stack very possible. Also there is No Pie which would mean that the addresses will remain the same every time the binary is ran.&lt;/p&gt;</description>
    </item>
    <item>
      <title>pwn102</title>
      <link>http://localhost:1313/blog/posts/thm/binary102/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/posts/thm/binary102/</guid>
      <description>&lt;h2 id=&#34;102&#34;&gt;102&lt;/h2&gt;&#xA;&lt;h3 id=&#34;intoroduction&#34;&gt;Intoroduction&lt;/h3&gt;&#xA;&lt;p&gt;So for the next challenge we are required to modify a variable&amp;rsquo;s value. This occurs when data larger than the allocated memory space (buffer) is written into that buffer. As a result, it can overwrite adjacent memory, including variables. But then if the stack grows downwards and the return address is above the variables space it should write the the memory below and not above, right? No, what happens is functions called later get stack frames at lower memory, and the return address is pushed to the higher address than the local variables. But arrays and buffers are indexed upwards in memory, so writing past the end of the array will nicely land on the return address next on the stack.&lt;/p&gt;</description>
    </item>
    <item>
      <title>pwn103</title>
      <link>http://localhost:1313/blog/posts/thm/binary103/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/posts/thm/binary103/</guid>
      <description>&lt;h2 id=&#34;103&#34;&gt;103&lt;/h2&gt;&#xA;&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;&#xA;&lt;p&gt;Here we are met by a ret2win challenge, what this means is that we are required to call a function which does something that is not normal, example spawn a shell or in case of a CTF it prints out the flag. We can start by doing simple binary analysis for example checking the binary protections using &lt;code&gt;checksec&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Let us break all this down bit by bit.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    Arch:     amd64-64-little&#xA;    RELRO:    Partial RELRO&#xA;    Stack:    No canary found&#xA;    NX:       NX enabled&#xA;    PIE:      No PIE (0x400000)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Arch: amd64-64-little&#xA;This line specifies the architecture of the binary. &amp;ldquo;amd64&amp;rdquo; refers to the x86-64 architecture, a common architecture for modern desktop and server CPUs. &amp;ldquo;64-little&amp;rdquo; indicates that it&amp;rsquo;s a 64-bit architecture (as opposed to 32-bit) and uses little-endian byte ordering.&lt;/p&gt;</description>
    </item>
    <item>
      <title>pwn104</title>
      <link>http://localhost:1313/blog/posts/thm/binary104/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/posts/thm/binary104/</guid>
      <description>&lt;h2 id=&#34;104&#34;&gt;104&lt;/h2&gt;&#xA;&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;&#xA;&lt;p&gt;First of all we are going to do some file checks, to see the binary protections and determine the file type&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pwn104.pwn104: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=60e0bab59b4e5412a1527ae562f5b8e58928a7cb, for GNU/Linux 3.2.0, not stripped&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can see that the binary is a 64 bit Least Significant Byte executable, in other words it uses little endian. The binary is dynamically linked to a LIBC and it is not stripped.&lt;/p&gt;</description>
    </item>
    <item>
      <title>pwn101</title>
      <link>http://localhost:1313/blog/posts/thm/binary101/</link>
      <pubDate>Fri, 05 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/posts/thm/binary101/</guid>
      <description>&lt;p&gt;Hello guys and welcome to my walkthrough along this journey of binary exploitation. In this wreiteup we shall be handling the pwn101 room on &lt;a href=&#34;https://tryhackme.com/room/pwn101&#34;&gt;tryhackme&lt;/a&gt;. Before jumping into this room, there are some prerequisites to complete the challenges:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;1. C programming language&#xA;2. Assembly language (basics)&#xA;3. Some experience in reverse engineering, using debuggers, understanding low-level concepts&#xA;4. Python scripting and pwntools&#xA;5. A lot of patience&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s learn.&lt;/p&gt;&#xA;&lt;h2 id=&#34;101&#34;&gt;101&lt;/h2&gt;&#xA;&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;&#xA;&lt;p&gt;So we first begin with some easy task, I reckon it is gonna be a buffer overflow, I will explain this in the analysis parts. So basically we just need t&#xA;we get an idea that this might be a simple buffer overflow. A buffer overflow or buffer overrun is an anomaly whereby a program writes data to a buffer beyond the buffer&amp;rsquo;s allocated memory, overwriting adjacent memory locations.&#xA;Example would look like.&#xA;&lt;img src=&#34;https://i.ibb.co/3RLRrq8/example-overflow.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
